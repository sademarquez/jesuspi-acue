document.addEventListener('DOMContentLoaded', function () {
    // --- Elementos del DOM ---
    const mobileMenuButton = document.getElementById('mobile-menu-button');
    const mobileMenu = document.getElementById('mobile-menu');
    const header = document.getElementById('main-header');
    const sections = document.querySelectorAll('main section');
    const navLinks = document.querySelectorAll('.nav-link');
    const contentGrid = document.getElementById('content-grid');
    const filterButtons = document.querySelectorAll('.filter-btn');

    // --- Carrusel (Trayectoria) ---
    const carouselTrack = document.getElementById('carousel-track');
    const carouselPrev = document.getElementById('carousel-prev');
    const carouselNext = document.getElementById('carousel-next');
    const carouselDotsContainer = document.getElementById('carousel-dots');
    let currentIndex = 0;
    let autoSlideInterval;
    let startX = 0; // Para el swipe en móviles
    let currentTranslate = 0; // Para el seguimiento del arrastre (no usado actualmente, pero mantenido)

    // Datos del carrusel: Ahora se cargarán desde timeline-data.json
    let carouselContentData = []; 

    // --- Funciones del Carrusel ---

    function initializeCarousel() {
        if (!carouselTrack || !carouselDotsContainer || carouselContentData.length === 0) {
            console.warn("No se pudo inicializar el carrusel: elementos DOM no encontrados o datos vacíos.");
            return;
        }

        carouselTrack.innerHTML = ''; // Limpiar el track por si acaso
        carouselDotsContainer.innerHTML = ''; // Limpiar los puntos

        carouselContentData.forEach((item, index) => {
            // Crea el slide
            const slide = document.createElement('div');
            // Se mantienen las clases de Tailwind y se añade la clase CSS personalizada 'carousel-slide'
            slide.classList.add('carousel-slide', 'w-full', 'max-w-xs', 'mx-auto', 'md:ml-auto', 'md:mr-auto', 'p-4', 'bg-soft-cream', 'rounded-lg', 'shadow-lg');
            slide.setAttribute('data-index', index);

            slide.innerHTML = `
                <img src="images/${item.image}" alt="${item.title}" class="w-full h-48 object-cover rounded-md mb-4">
                <h3 class="text-xl font-semibold text-deep-charcoal mb-2">${item.title}</h3>
                <p class="text-deep-charcoal mb-2">${item.description}</p>
                <p class="text-dark-gold font-bold">${item.year}</p>
            `;
            carouselTrack.appendChild(slide);

            // Crea los puntos de navegación
            const dot = document.createElement('button');
            dot.classList.add('w-3', 'h-3', 'rounded-full', 'bg-dark-gold', 'opacity-50', 'transition-opacity', 'duration-300');
            dot.setAttribute('data-index', index);
            dot.addEventListener('click', () => showSlide(index));
            carouselDotsContainer.appendChild(dot);
        });

        updateCarouselDisplay(); // Muestra el primer slide y activa el punto
    }

    function showSlide(index) {
        if (carouselContentData.length === 0) return; // Evitar errores si no hay datos

        currentIndex = (index + carouselContentData.length) % carouselContentData.length;
        
        // Obtiene el elemento del slide objetivo
        const targetSlide = carouselTrack.children[currentIndex];
        if (targetSlide) {
            // Desplazamiento al inicio del slide objetivo
            carouselTrack.scrollTo({
                left: targetSlide.offsetLeft, 
                behavior: 'smooth'
            });
        }
        updateCarouselDisplay();
        resetAutoSlide(); // Reiniciar el auto-avance al cambiar manualmente
    }

    function nextSlide() {
        showSlide(currentIndex + 1);
    }

    function prevSlide() {
        showSlide(currentIndex - 1);
    }

    function updateCarouselDisplay() {
        const dots = carouselDotsContainer.querySelectorAll('button');
        dots.forEach((dot, idx) => {
            if (idx === currentIndex) {
                dot.classList.add('opacity-100');
            } else {
                dot.classList.remove('opacity-100');
            }
        });
    }

    // --- Lógica de Swipe ---
    const swipeThreshold = 50; // Pixeles para considerar un swipe

    if (carouselTrack) {
        carouselTrack.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            clearInterval(autoSlideInterval); // Pausar auto-avance al tocar
        });

        carouselTrack.addEventListener('touchend', (e) => {
            const endX = e.changedTouches[0].clientX;
            const diffX = startX - endX;

            if (diffX > swipeThreshold) {
                // Swipe a la izquierda (next slide)
                nextSlide();
            } else if (diffX < -swipeThreshold) {
                // Swipe a la derecha (prev slide)
                prevSlide();
            }
            startAutoSlide(); // Reanudar auto-avance después del swipe
        });
    }
    
    // --- Auto-avance del Carrusel ---
    function startAutoSlide() {
        clearInterval(autoSlideInterval); // Limpiar cualquier intervalo anterior
        autoSlideInterval = setInterval(() => {
            nextSlide();
        }, 4000); // <-- VELOCIDAD DEL CARRUSEL: Ajustado a 4000ms (4 segundos) para una transición más suave
    }

    function resetAutoSlide() {
        clearInterval(autoSlideInterval);
        startAutoSlide();
    }

    // --- Inicialización del Carrusel: Cargar datos desde JSON ---
    fetch('timeline-data.json') // Asegúrate que esta ruta sea correcta
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            carouselContentData = data; // Asigna los datos del JSON
            initializeCarousel(); // Ahora sí, inicializa el carrusel con los datos cargados
            if (carouselContentData.length > 1) { // Solo inicia auto-avance si hay más de un slide
                startAutoSlide();
            }
        })
        .catch(error => {
            console.error('Error al cargar los datos de la trayectoria:', error);
            // Opcional: Mostrar un mensaje de error al usuario o usar datos de respaldo
        });


    // --- Navegación del Carrusel (Event Listeners) ---
    if (carouselPrev) {
        carouselPrev.addEventListener('click', prevSlide);
    }
    if (carouselNext) {
        carouselNext.addEventListener('click', nextSlide);
    }
    // Los puntos se añaden dinámicamente, su evento se maneja en initializeCarousel

    // --- Header Scroll y Menú Móvil ---

    // --- Función para cerrar el menú móvil de forma consistente ---
    function closeMobileMenu() {
        if (mobileMenu && mobileMenu.classList.contains('active')) {
            mobileMenu.classList.remove('active');
            // Se elimina la lógica de ocultar/mostrar iconos SVG, ahora el CSS maneja la animación de los <span>
            mobileMenuButton.classList.remove('active'); // Desactiva la clase en el botón para la animación
        }
    }
    // --- FIN Nueva función ---

    if (mobileMenuButton && mobileMenu) {
        mobileMenuButton.addEventListener('click', (event) => {
            event.stopPropagation(); // Evita que el clic en el botón se propague al body y cierre el menú inmediatamente
            mobileMenu.classList.toggle('active');
            // Se añade/elimina la clase 'active' al botón para la animación de hamburguesa a cruz
            mobileMenuButton.classList.toggle('active'); 
        });
    }

    // --- Nuevo: Cerrar el menú al hacer clic FUERA del menú o del botón ---
    document.body.addEventListener('click', (event) => {
        // Si el menú está abierto, y el clic NO fue en el botón del menú
        // y el clic NO fue dentro del propio menú móvil
        if (mobileMenu && mobileMenu.classList.contains('active') && 
            !mobileMenuButton.contains(event.target) && 
            !mobileMenu.contains(event.target)) {
            closeMobileMenu(); // Llama a la función de cierre
        }
    });


    if (header) {
        window.addEventListener('scroll', () => {
            if (window.scrollY > 50) {
                header.classList.add('header-scrolled');
            } else {
                header.classList.remove('header-scrolled');
            }
        });
    }

    // --- Navegación activa al hacer scroll ---
    window.addEventListener('scroll', () => {
        let currentSection = '';
        sections.forEach(section => {
            const sectionTop = section.offsetTop - (header ? header.offsetHeight : 0) - 20; // Ajuste para el header fijo
            const sectionHeight = section.clientHeight;
            if (pageYOffset >= sectionTop && pageYOffset < sectionTop + sectionHeight) {
                currentSection = section.getAttribute('id');
            }
        });

        navLinks.forEach(link => {
            // Se asegura que la clase 'text-dark-gold' se use para el estado activo
            link.classList.remove('text-dark-gold'); 
            if (link.getAttribute('data-section') === currentSection) { // Usa data-section para mayor robustez
                link.classList.add('text-dark-gold');
            }
        });
    });

    // --- Lógica de Filtrado de Contenido (Pensamiento y Acción) ---
    let contentData = []; 

    function displayContent(items) {
        if (!contentGrid) return;
        contentGrid.innerHTML = '';
        items.forEach(item => {
            const itemElement = document.createElement('div');
            itemElement.classList.add('content-item');
            itemElement.innerHTML = `
                <img src="${item.image}" alt="${item.title}" class="w-full h-48 object-cover">
                <div class="content-item-body p-4">
                    <h3 class="text-xl font-semibold mb-2">${item.title}</h3>
                    <p class="text-deep-charcoal mb-2">${item.description}</p>
                    <a href="${item.link}" target="_blank" rel="noopener noreferrer" class="text-dark-gold font-bold hover:underline">Leer más</a>
                </div>
            `;
            contentGrid.appendChild(itemElement);
        });
    }

    function filterContent(category) {
        const filtered = category === 'todos' ? contentData : contentData.filter(item => item.category === category);
        displayContent(filtered);

        filterButtons.forEach(button => {
            // Se asegura que las clases de Tailwind para el estado activo/inactivo sean consistentes
            button.classList.remove('bg-dark-gold', 'text-soft-cream');
            button.classList.add('bg-deep-charcoal', 'text-white'); // Estado inactivo
        });
        const activeButton = document.querySelector(`.filter-btn[data-filter="${category}"]`);
        if (activeButton) {
            activeButton.classList.remove('bg-deep-charcoal', 'text-white');
            activeButton.classList.add('bg-dark-gold', 'text-soft-cream'); // Estado activo
        }
    }

    // Cargar content.json para la sección de Pensamiento y Acción
    fetch('content.json')
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            contentData = data;
            filterContent('todos'); // Muestra todo al cargar
            filterButtons.forEach(button => {
                button.addEventListener('click', () => {
                    filterContent(button.dataset.filter);
                });
            });
        })
        .catch(error => console.error('Error al cargar el contenido para Pensamiento y Acción:', error));

    // --- Función para el desplazamiento suave para enlaces de anclaje ---
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
                const headerHeight = header ? header.offsetHeight : 0;
                window.scrollTo({
                    top: targetElement.offsetTop - headerHeight,
                    behavior: 'smooth'
                });
            }
            // Cerrar menú móvil si está abierto y el enlace clickeado es parte del menú móvil
            if (mobileMenu && mobileMenu.contains(this)) { 
                closeMobileMenu(); // Llama a la nueva función de cierre
            }
        });
    });
});
