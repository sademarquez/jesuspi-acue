document.addEventListener('DOMContentLoaded', function () {
    // --- Elementos del DOM ---
    const mobileMenuButton = document.getElementById('mobile-menu-button');
    const mobileMenu = document.getElementById('mobile-menu');
    const header = document.getElementById('main-header');
    const sections = document.querySelectorAll('main section');
    const navLinks = document.querySelectorAll('.nav-link');
    const contentGrid = document.getElementById('content-grid');
    const filterButtons = document.querySelectorAll('.filter-btn');

    // --- Carrusel (Trayectoria) ---
    const carouselTrack = document.getElementById('carousel-track');
    const carouselPrev = document.getElementById('carousel-prev');
    const carouselNext = document.getElementById('carousel-next');
    const carouselDotsContainer = document.getElementById('carousel-dots');
    let currentIndex = 0;
    let autoSlideInterval;
    let startX = 0; // Para el swipe en móviles
    let currentTranslate = 0; // Para el seguimiento del arrastre (no usado actualmente, pero mantenido)

    // Datos del carrusel: Ahora se cargarán desde timeline-data.json
    let carouselContentData = []; 

    // --- Funciones del Carrusel ---

    function initializeCarousel() {
        if (!carouselTrack || !carouselDotsContainer || carouselContentData.length === 0) {
            console.warn("No se pudo inicializar el carrusel: elementos DOM no encontrados o datos vacíos.");
            return;
        }

        carouselTrack.innerHTML = ''; // Limpiar el track por si acaso
        carouselDotsContainer.innerHTML = ''; // Limpiar los puntos

        carouselContentData.forEach((item, index) => {
            // Crea el slide
            const slide = document.createElement('div');
            slide.classList.add('carousel-slide', 'w-full', 'max-w-xs', 'mx-auto', 'md:ml-auto', 'md:mr-auto', 'p-4', 'bg-soft-cream', 'rounded-lg', 'shadow-lg');
            slide.setAttribute('data-index', index);

            // Using textContent for title and description to prevent XSS
            const imgElement = document.createElement('img');
            imgElement.src = `images/${item.image}`;
            imgElement.alt = item.title; // Alt text from title
            imgElement.classList.add('w-full', 'h-48', 'object-cover', 'rounded-md', 'mb-4');

            const h3Element = document.createElement('h3');
            h3Element.classList.add('text-xl', 'font-semibold', 'text-deep-charcoal', 'mb-2');
            h3Element.textContent = item.title;

            const pDescriptionElement = document.createElement('p');
            pDescriptionElement.classList.add('text-deep-charcoal', 'mb-2');
            pDescriptionElement.textContent = item.description;

            const pYearElement = document.createElement('p');
            pYearElement.classList.add('text-dark-gold', 'font-bold');
            pYearElement.textContent = item.year;

            slide.appendChild(imgElement);
            slide.appendChild(h3Element);
            slide.appendChild(pDescriptionElement);
            slide.appendChild(pYearElement);

            carouselTrack.appendChild(slide);

            // Crea los puntos de navegación
            const dot = document.createElement('button');
            dot.classList.add('w-3', 'h-3', 'rounded-full', 'bg-dark-gold', 'opacity-50', 'transition-opacity', 'duration-300');
            dot.setAttribute('data-index', index);
            dot.setAttribute('role', 'button'); // ARIA role for accessibility
            dot.setAttribute('aria-label', `Go to slide ${index + 1}`); // ARIA label
            dot.addEventListener('click', () => showSlide(index));
            // Add keyboard navigation for dots
            dot.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    showSlide(index);
                }
            });
            carouselDotsContainer.appendChild(dot);
        });

        updateCarouselDisplay(); // Muestra el primer slide y activa el punto
    }

    function showSlide(index) {
        if (carouselContentData.length === 0) return; // Evitar errores si no hay datos

        currentIndex = (index + carouselContentData.length) % carouselContentData.length;
        
        // Calculate scroll position more accurately by getting the actual element position
        const targetSlide = carouselTrack.children[currentIndex];
        if (targetSlide) {
            carouselTrack.scrollTo({
                left: targetSlide.offsetLeft - carouselTrack.offsetLeft, // Use offsetLeft for precise positioning
                behavior: 'smooth'
            });
        }
        updateCarouselDisplay();
        resetAutoSlide(); // Reiniciar el auto-avance al cambiar manualmente
    }

    function nextSlide() {
        showSlide(currentIndex + 1);
    }

    function prevSlide() {
        showSlide(currentIndex - 1);
    }

    function updateCarouselDisplay() {
        const dots = carouselDotsContainer.querySelectorAll('button');
        dots.forEach((dot, idx) => {
            if (idx === currentIndex) {
                dot.classList.add('opacity-100');
                dot.setAttribute('aria-current', 'true'); // ARIA attribute for current slide
            } else {
                dot.classList.remove('opacity-100');
                dot.removeAttribute('aria-current');
            }
        });
    }

    // --- Lógica de Swipe ---
    const swipeThreshold = 50; // Pixeles para considerar un swipe
    let touchMoveX = 0;

    if (carouselTrack) {
        carouselTrack.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            clearInterval(autoSlideInterval); // Pausar auto-avance al tocar
            // Optional: prevent vertical scroll during horizontal swipe (can be tricky to get right)
            // carouselTrack.addEventListener('touchmove', handleTouchMove, { passive: false });
        }, { passive: true }); // Use passive: true for better scroll performance

        // function handleTouchMove(e) {
        //     const currentX = e.touches[0].clientX;
        //     touchMoveX = currentX - startX;
        //     // If horizontal movement is significant, prevent vertical scroll
        //     if (Math.abs(touchMoveX) > Math.abs(e.touches[0].clientY - e.clientY)) {
        //         e.preventDefault();
        //     }
        // }

        carouselTrack.addEventListener('touchend', (e) => {
            // carouselTrack.removeEventListener('touchmove', handleTouchMove);
            const endX = e.changedTouches[0].clientX;
            const diffX = startX - endX;

            if (diffX > swipeThreshold) {
                nextSlide();
            } else if (diffX < -swipeThreshold) {
                prevSlide();
            }
            // Agregar un retraso antes de reanudar el auto-avance
            setTimeout(resetAutoSlide, 3000); // 3 segundos de retraso
        }, { passive: true }); // Use passive: true
    }

    // --- Auto-avance del carrusel ---
    function startAutoSlide() {
        clearInterval(autoSlideInterval); // Limpiar cualquier intervalo existente
        autoSlideInterval = setInterval(() => {
            showSlide(currentIndex + 1);
        }, 7000); // Avanza cada 7 segundos (Mejora: de 5s a 7s)
    }

    function resetAutoSlide() {
        startAutoSlide(); // Simplemente reinicia el intervalo
    }

    // --- Listeners para botones de navegación del carrusel ---
    if (carouselPrev) {
        carouselPrev.addEventListener('click', prevSlide);
    }
    if (carouselNext) {
        carouselNext.addEventListener('click', nextSlide);
    }

    // --- Intersection Observer para animaciones de sección ---
    const sectionObserverOptions = {
        root: null, // viewport
        rootMargin: '0px',
        threshold: 0.1 // Cuando el 10% de la sección es visible
    };

    const sectionObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.classList.add('is-visible');
                observer.unobserve(entry.target); // Dejar de observar una vez que sea visible
            }
        });
    }, sectionObserverOptions);

    sections.forEach(section => {
        sectionObserver.observe(section);
    });

    // --- Lógica de scroll para resaltar enlaces de navegación ---
    const observerOptions = {
        root: null,
        rootMargin: '-50% 0px -50% 0px', // Activa el enlace cuando la sección está en el centro de la pantalla
        threshold: 0 // No necesitamos un umbral, solo el rootMargin
    };

    const navObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const sectionId = entry.target.id;
                navLinks.forEach(link => {
                    link.classList.remove('text-dark-gold');
                    if (link.getAttribute('href') === `#${sectionId}`) {
                        link.classList.add('text-dark-gold');
                    }
                });
            }
        });
    }, observerOptions);

    sections.forEach(section => {
        navObserver.observe(section);
    });

    // --- Efecto de scroll en el HEADER ---
    const headerHeight = header ? header.offsetHeight : 0;
    const scrollThreshold = 50; // Cuántos px scrollear para activar el efecto

    function updateHeaderOnScroll() {
        if (window.scrollY > scrollThreshold) {
            header.classList.add('header-scrolled');
        } else {
            header.classList.remove('header-scrolled');
        }
    }

    // Throttle function to limit scroll event calls
    function throttle(func, delay) {
        let timeoutId;
        let lastArgs;
        let lastThis;
        let lastExecTime = 0;

        return function(...args) {
            const currentTime = Date.now();
            lastArgs = args;
            lastThis = this;

            if (currentTime - lastExecTime > delay) {
                lastExecTime = currentTime;
                func.apply(lastThis, lastArgs);
            } else {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    lastExecTime = Date.now();
                    func.apply(lastThis, lastArgs);
                }, delay - (currentTime - lastExecTime));
            }
        };
    }

    window.addEventListener('scroll', throttle(() => {
        updateHeaderOnScroll();
        // updateNavLinkActiveState(); // This function is not defined here, assume it's part of navObserver
    }, 100)); // Changed from 16ms to 100ms

    // Llama a la función al cargar la página para establecer el estado inicial del header
    updateHeaderOnScroll();

    // Debounced resize handler (Placeholder)
    let resizeTimer;
    function debounce(func, delay) {
        return function(...args) {
            const context = this;
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => func.apply(context, args), delay);
        };
    }

    function updateCarouselLayout() {
        // Implement logic to recalculate carousel slide positions or redraw if necessary
        // For example, if slideWidth depends on viewport width
        console.log("Carousel layout updated after resize (debounced).");
        // Re-initialize carousel or adjust specific dimensions here if needed
        // initializeCarousel(); // This might be too heavy, focus on specific adjustments
        showSlide(currentIndex); // Ensure current slide is correctly positioned after resize
    }

    window.addEventListener('resize', debounce(updateCarouselLayout, 250)); // Debounce resize by 250ms


    // --- Manejo del menú móvil ---
    function openMobileMenu() {
        mobileMenu.classList.add('active');
        mobileMenuButton.querySelector('.hamburger-icon').classList.add('hidden');
        mobileMenuButton.querySelector('.close-icon').classList.remove('hidden');
        // Update ARIA attributes
        mobileMenuButton.setAttribute('aria-expanded', 'true');
        document.body.classList.add('overflow-hidden'); // Prevent scrolling body
    }

    function closeMobileMenu() {
        mobileMenu.classList.remove('active');
        mobileMenuButton.querySelector('.hamburger-icon').classList.remove('hidden');
        mobileMenuButton.querySelector('.close-icon').classList.add('hidden');
        // Update ARIA attributes
        mobileMenuButton.setAttribute('aria-expanded', 'false');
        document.body.classList.remove('overflow-hidden'); // Allow scrolling body
    }

    if (mobileMenuButton) {
        mobileMenuButton.addEventListener('click', () => {
            if (mobileMenu.classList.contains('active')) {
                closeMobileMenu();
            } else {
                openMobileMenu();
            }
        });
    }

    // --- Cargar contenido dinámico para "Pensamiento y Acción" ---
    let contentData = []; // Para almacenar el contenido de content.json

    function renderContent(dataToRender) {
        if (!contentGrid) return;
        contentGrid.innerHTML = ''; // Limpiar el grid

        if (dataToRender.length === 0) {
            contentGrid.innerHTML = '<p class="text-center text-deep-charcoal col-span-full">No hay contenido disponible para esta categoría.</p>';
            return;
        }

        dataToRender.forEach(item => {
            const contentItem = document.createElement('div');
            contentItem.classList.add('content-item');
            
            // Using textContent for title and description to prevent XSS
            const imgElement = document.createElement('img');
            imgElement.src = item.image;
            imgElement.alt = item.title;
            imgElement.classList.add('w-full', 'h-48', 'object-cover');

            const textDiv = document.createElement('div');
            textDiv.classList.add('content-item-text');

            const h3Element = document.createElement('h3');
            h3Element.textContent = item.title;

            const pElement = document.createElement('p');
            pElement.textContent = item.description;

            const aElement = document.createElement('a');
            aElement.href = item.link;
            aElement.target = '_blank';
            aElement.rel = 'noopener noreferrer';
            aElement.textContent = 'Leer más';

            textDiv.appendChild(h3Element);
            textDiv.appendChild(pElement);
            textDiv.appendChild(aElement);

            contentItem.appendChild(imgElement);
            contentItem.appendChild(textDiv);
            contentGrid.appendChild(contentItem);
        });
    }

    function filterContent(category) {
        let filtered = contentData;
        if (category !== 'todos') {
            filtered = contentData.filter(item => item.category === category);
        }
        renderContent(filtered);
    }

    // Cargar timeline-data.json
    fetch('timeline-data.json')
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            // Validate data structure for timeline-data.json
            if (Array.isArray(data) && data.every(item =>
                item.title && typeof item.title === 'string' &&
                item.description && typeof item.description === 'string' &&
                item.year && typeof item.year === 'string' &&
                item.image && typeof item.image === 'string'
            )) {
                carouselContentData = data;
                initializeCarousel();
                startAutoSlide(); // Inicia el auto-avance solo después de cargar
            } else {
                throw new Error('Estructura de datos inválida para timeline-data.json. Por favor, verifica el formato.');
            }
        })
        .catch(error => {
            console.error('Error al cargar el contenido de la trayectoria:', error);
            if (carouselTrack) {
                 carouselTrack.innerHTML = '<p class="text-center text-deep-charcoal col-span-full">Error al cargar la trayectoria. Por favor, inténtalo más tarde.</p>';
            }
        });

    // Cargar content.json
    fetch('content.json')
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            // Validate data structure for content.json
            if (Array.isArray(data) && data.every(item =>
                item.category && typeof item.category === 'string' &&
                item.title && typeof item.title === 'string' &&
                item.description && typeof item.description === 'string' &&
                item.image && typeof item.image === 'string' &&
                item.link && typeof item.link === 'string'
            )) {
                contentData = data;
                filterContent('todos'); // Muestra todo al cargar
                filterButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        filterContent(button.dataset.filter);
                    });
                });
            } else {
                throw new Error('Estructura de datos inválida para content.json. Por favor, verifica el formato.');
            }
        })
        .catch(error => {
            console.error('Error al cargar el contenido para Pensamiento y Acción:', error);
            if (contentGrid) {
                contentGrid.innerHTML = '<p class="text-center text-deep-charcoal col-span-full">Error al cargar el contenido. Por favor, inténtalo más tarde.</p>';
            }
        });

    // --- Función para el desplazamiento suave para enlaces de anclaje ---
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
                const headerHeight = header ? header.offsetHeight : 0;
                window.scrollTo({
                    top: targetElement.offsetTop - headerHeight,
                    behavior: 'smooth'
                });
            }
            // Cerrar menú móvil si está abierto y el enlace clickeado es parte del menú móvil
            if (mobileMenu && mobileMenu.contains(this)) { 
                closeMobileMenu(); // Llama a la nueva función de cierre
            }
        });
    });
});
