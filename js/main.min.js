document.addEventListener('DOMContentLoaded', function () {
    // --- Elementos del DOM ---
    const mobileMenuButton = document.getElementById('mobile-menu-button');
    const mobileMenu = document.getElementById('mobile-menu');
    const header = document.getElementById('main-header');
    const sections = document.querySelectorAll('main section');
    const navLinks = document.querySelectorAll('.nav-link');
    const contentGrid = document.getElementById('content-grid');
    const filterButtons = document.querySelectorAll('.filter-btn');

    // --- Carrusel (Trayectoria) ---
    const carouselTrack = document.getElementById('carousel-track');
    const carouselPrev = document.getElementById('carousel-prev');
    const carouselNext = document.getElementById('carousel-next');
    const carouselDotsContainer = document.getElementById('carousel-dots');
    let currentIndex = 0;
    let autoSlideInterval;
    let startX = 0; // Para el swipe en móviles
    let currentTranslate = 0; // Para el seguimiento del arrastre (no usado actualmente, pero mantenido)

    // Datos del carrusel: Ahora se cargarán desde timeline-data.json
    let carouselContentData = [];

    // --- Funciones del Carrusel ---

    function initializeCarousel() {
        if (!carouselTrack || !carouselDotsContainer) {
            console.warn("No se pudo inicializar el carrusel: elementos DOM no encontrados.");
            return;
        }

        fetch('timeline-data.json')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                carouselContentData = data;
                renderCarouselSlides();
                renderCarouselDots();
                showSlide(currentIndex); // Mostrar la primera slide
                startAutoSlide();
            })
            .catch(error => console.error('Error al cargar los datos del carrusel:', error));
    }

    function renderCarouselSlides() {
        carouselTrack.innerHTML = '';
        carouselContentData.forEach((item, index) => {
            const slide = document.createElement('div');
            slide.classList.add('carousel-slide', 'bg-white', 'rounded-lg', 'shadow-md', 'p-6', 'text-center', 'flex-shrink-0');
            slide.innerHTML = `
                <img src="images/${item.image}" alt="${item.title}" class="w-full h-48 object-cover rounded-md mb-4">
                <h3 class="text-xl font-semibold text-deep-charcoal mb-2">${item.title}</h3>
                <p class="text-gray-600 mb-2">${item.year}</p>
                <p class="text-deep-charcoal text-sm">${item.description}</p>
            `;
            carouselTrack.appendChild(slide);
        });
    }

    function renderCarouselDots() {
        carouselDotsContainer.innerHTML = '';
        carouselContentData.forEach((_, index) => {
            const dot = document.createElement('span');
            dot.classList.add('carousel-dot');
            if (index === currentIndex) {
                dot.classList.add('active');
            }
            dot.addEventListener('click', () => {
                showSlide(index);
                resetAutoSlide();
            });
            carouselDotsContainer.appendChild(dot);
        });
    }

    // Mejorar función showSlide para usar scroll-snap
    function showSlide(index) {
        if (carouselContentData.length === 0) return;

        currentIndex = (index + carouselContentData.length) % carouselContentData.length;

        // Usar scrollLeft en lugar de scrollTo para mejor compatibilidad
        const slideWidth = carouselTrack.children[0] ? carouselTrack.children[0].offsetWidth + 16 : 0; // +16 para el gap
        carouselTrack.scrollLeft = currentIndex * slideWidth;

        updateCarouselDisplay();
        resetAutoSlide();
    }

    function updateCarouselDisplay() {
        const dots = document.querySelectorAll('.carousel-dot');
        dots.forEach((dot, index) => {
            if (index === currentIndex) {
                dot.classList.add('active');
            } else {
                dot.classList.remove('active');
            }
        });
    }

    function startAutoSlide() {
        clearInterval(autoSlideInterval); // Limpiar cualquier intervalo existente
        autoSlideInterval = setInterval(() => {
            showSlide(currentIndex + 1);
        }, 5000); // Cambia de slide cada 5 segundos
    }

    function resetAutoSlide() {
        startAutoSlide(); // Reinicia el temporizador
    }

    // Navegación del carrusel
    if (carouselPrev) {
        carouselPrev.addEventListener('click', () => {
            showSlide(currentIndex - 1);
        });
    }

    if (carouselNext) {
        carouselNext.addEventListener('click', () => {
            showSlide(currentIndex + 1);
        });
    }

    // Pausar autoplay cuando el usuario hace hover o toca
    if (carouselTrack) {
        carouselTrack.addEventListener('mouseenter', () => clearInterval(autoSlideInterval));
        carouselTrack.addEventListener('mouseleave', startAutoSlide);

        // Para móvil
        carouselTrack.addEventListener('touchstart', () => clearInterval(autoSlideInterval));
        carouselTrack.addEventListener('touchend', startAutoSlide);

        // Swipe en móviles
        carouselTrack.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            currentTranslate = carouselTrack.scrollLeft;
        });

        carouselTrack.addEventListener('touchmove', (e) => {
            const currentX = e.touches[0].clientX;
            const diff = startX - currentX;
            carouselTrack.scrollLeft = currentTranslate + diff;
        });

        carouselTrack.addEventListener('touchend', () => {
            // Ajustar a la slide más cercana después del swipe
            const slideWidth = carouselTrack.children[0] ? carouselTrack.children[0].offsetWidth + 16 : 0;
            const scrolled = carouselTrack.scrollLeft;
            currentIndex = Math.round(scrolled / slideWidth);
            showSlide(currentIndex);
            resetAutoSlide();
        });
    }

    initializeCarousel(); // Inicializar el carrusel al cargar la página

    // --- Funcionalidad del Menú Móvil ---
    if (mobileMenuButton && mobileMenu) {
        mobileMenuButton.addEventListener('click', () => {
            mobileMenu.classList.toggle('active');
            // Cambiar icono del botón
            const icon = mobileMenuButton.querySelector('svg path');
            if (mobileMenu.classList.contains('active')) {
                icon.setAttribute('d', 'M6 18L18 6M6 6l12 12'); // Icono de 'X'
            } else {
                icon.setAttribute('d', 'M4 6h16M4 12h16m-7 6h7'); // Icono de hamburguesa
            }
        });

        // Cerrar menú móvil al hacer clic en un enlace
        mobileMenu.querySelectorAll('a').forEach(link => {
            link.addEventListener('click', () => {
                closeMobileMenu();
            });
        });
    }

    function closeMobileMenu() {
        if (mobileMenu && mobileMenuButton && mobileMenu.classList.contains('active')) {
            mobileMenu.classList.remove('active');
            mobileMenuButton.querySelector('svg path').setAttribute('d', 'M4 6h16M4 12h16m-7 6h7'); // Restaurar icono de hamburguesa
        }
    }

    // --- Resaltar el enlace de navegación activo ---
    // Función para obtener la sección visible actual
    const getVisibleSection = () => {
        let visibleSectionId = '';
        const scrollPosition = window.scrollY + (header ? header.offsetHeight : 0) + 1; // +1 para asegurar
        sections.forEach(section => {
            if (section.offsetTop <= scrollPosition && section.offsetTop + section.offsetHeight > scrollPosition) {
                visibleSectionId = section.id;
            }
        });
        return visibleSectionId;
    };

    // Función para actualizar la clase 'active' de los enlaces
    const updateNavLinkActiveState = () => {
        const currentSectionId = getVisibleSection();
        navLinks.forEach(link => {
            if (link.getAttribute('href') === `#${currentSectionId}`) {
                link.classList.add('text-dark-gold');
                link.classList.remove('text-soft-cream');
            } else {
                link.classList.remove('text-dark-gold');
                link.classList.add('text-soft-cream');
            }
        });
        // Asegurar que el logo también cambie de color si es un nav-link (no aplica directamente aquí)
    };

    // Aplica a scroll events con throttle
    // Añadir función throttle
    function throttle(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    window.addEventListener('scroll', throttle(() => {
        updateNavLinkActiveState();
    }, 16)); // ~60fps

    // Ejecutar al cargar para establecer el estado inicial
    updateNavLinkActiveState();


    // --- Carga y Filtrado de Contenido para Pensamiento y Acción ---
    let contentData = []; // Variable para almacenar los datos cargados

    // Función para renderizar el contenido filtrado
    function filterContent(category) {
        const filtered = category === 'all' ? contentData : contentData.filter(item => item.category === category); // Corrección: 'todos' a 'all'

        contentGrid.innerHTML = ''; // Limpiar el contenedor
        if (filtered.length === 0) {
            contentGrid.innerHTML = '<p class="text-center text-gray-500 col-span-full">No hay contenido disponible para esta categoría.</p>';
            return;
        }

        filtered.forEach(item => {
            const contentItem = document.createElement('div');
            contentItem.classList.add('content-item', 'bg-white', 'rounded-lg', 'shadow-md', 'overflow-hidden', 'transform', 'hover:scale-105', 'transition-transform', 'duration-300');
            contentItem.innerHTML = `
                <img src="${item.image}" alt="${item.title}" class="w-full h-48 object-cover">
                <div class="p-6">
                    <span class="inline-block bg-muted-gold text-deep-charcoal text-xs font-semibold px-3 py-1 rounded-full mb-2">${item.category.charAt(0).toUpperCase() + item.category.slice(1)}</span>
                    <h3 class="text-xl font-semibold text-deep-charcoal mb-2">${item.title}</h3>
                    <p class="text-gray-600 text-sm mb-4">${item.description}</p>
                    <a href="${item.link}" class="text-dark-gold hover:underline font-semibold" target="_blank" rel="noopener noreferrer">Leer más</a>
                </div>
            `;
            contentGrid.appendChild(contentItem);
        });

        // Actualizar la clase 'active' de los botones de filtro
        filterButtons.forEach(button => {
            button.classList.remove('active', 'bg-dark-gold', 'text-white');
            button.classList.add('bg-deep-charcoal', 'text-white');
            if (button.dataset.category === category) { // Corrección: data-filter a data-category
                button.classList.add('active', 'bg-dark-gold', 'text-white');
                button.classList.remove('bg-deep-charcoal');
            }
        });
    }

    // Cargar los datos del contenido una vez
    fetch('content.json')
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            contentData = data;
            filterContent('all'); // Muestra todo al cargar (Corrección: 'todos' a 'all')
            filterButtons.forEach(button => {
                button.addEventListener('click', () => {
                    filterContent(button.dataset.category); // Corrección: dataset.filter a dataset.category
                });
            });
        })
        .catch(error => console.error('Error al cargar el contenido para Pensamiento y Acción:', error));

    // --- Función para el desplazamiento suave para enlaces de anclaje ---
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
                const headerHeight = header ? header.offsetHeight : 0;
                window.scrollTo({
                    top: targetElement.offsetTop - headerHeight,
                    behavior: 'smooth'
                });
            }
            // Cerrar menú móvil si está abierto y el enlace clickeado es parte del menú móvil
            if (mobileMenu && mobileMenu.contains(this)) {
                closeMobileMenu(); // Llama a la nueva función de cierre
            }
        });
    });
});
